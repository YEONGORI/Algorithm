### 두 큐 합 같게 만들기

> 이 문제를 해결할 때 큐를 pop하는 과정에서 vector의 erase 함수를 사용했다.
> earse 함수는 container size(n)만큼의 시간복잡도 O(n)을 갖는다.
>
> 따라서 문제에서 제시된 두 벡터(queue1, queue2)를 순회하는 시간 O(n)에 O(n)이 곱해져 총 O(n^2)의 시간복잡도를 갖게되어 시간초과가 발생한다.
>
> 결국 문제를 해결하기 위해서는 두 벡터를 배열처럼 사용해야한다. 때문에 두 배열(벡터)의 인덱스인 i1, i2를 사용해 배열의 시작 인덱스를 pop이 발생할 때 마다 1씩 늘려주었다.

---

### 프린터

> 문제를 읽으면서 우선순위 큐가 생각났다. 하지만 우선순위 별로 정렬하면 특정 문서가 언제 출력되는지 정확히 알 수 없다. 우선 순위가 더 높은 문서가 리스트에 있다면 출력 순위가 가장 뒤로 미뤄지기 때문이다.
>
> 그래서 큐를 사용했고 iteration을 사용하고 싶어서 큐가 아닌 덱을 사용해 문제를 풀었다.
>
> 처음에 for - auto를 사용한 순회를 큐에는 사용할 수 없다는 것을 몰라서 살짝 해맸지만 덱을 사용해 해결했다.

---

### 올바른 괄호

> 유명한 스택 문제다. 여는 괄호일 때는 스택에 push, 닫는 괄호일 때는 스택에서 pop하는데 스택이 비었는데 다시 닫는 괄호가 나올때는 올바르지 않은 괄호임에 유의하여 풀면 된다.

---

### 기능 개발

> 스택, 큐 문제지만 list를 사용해서 풀었다. 풀이 방법, 방향 둘다 맞았지만 디테일에서 틀려서 한시간동안 삽질을 했다. 
>
> pair를 사용했는데 pair<int, int> 이렇게 선언해야 했지만 pair<int, bool> 로 선언해서 계속 틀렸던 것이다. 이제 막히면 다지우고 다시하자

---

### 뒤에 있는 큰 수 찾기

> 처음에는 벡터를 사용한 풀이를 했다. 접근 방법도 맞고 논리도 맞았지만 erase를 할 때 문제가 발생했다. vector 내의 원소가 3, 3, 3 이렇게 주어지면 1번 인덱스의 값을 삭제하면 같은 값 전부가 삭제되는 것이다.
>
> 이 부분을 확인하는데 오래걸려서 시간을 굉장히 많이 사용했고 stack풀이로 변경해 문제를 해결했다. stack은 뒷큰수가 발견되면 pop을하고 발견되지 않으면 스택에 push하는 단순한 구조를 갖는다.

---

### 과제 진행하기

> plans 리스트를 전부 순회하면서 처리가 가능한 과제는 바로 answer 리스트에 담고 해당 과제를 plans에서 지우고, 첫번째 순회가 끝난 후에 두번째 순회를 돌면서 남은 element들을 answer 리스트에 담는 방식을 처음에 사용했다.
>
> 하지만 이 방식은 한 과제를 완료하고 다음 과제를 완료하기 까지 시간이 많이 남았을 때 밀린 과제를 해결하지 못한다. 그렇기 때문에 주어진 과제를 시간안에 못한 경우, 시간이 많이 남아 밀린 과제를 해야하는 경우 두 케이스를 조건문으로 분기해 해결하였다.