### 타겟 넘버

> 문제 유형에 DFS라고 써져있어서 방향을 미리 정하고 시작헀다. 하지만 dfs함수를 만드는 과정에서 몇가지 어려운 점이 있었다.
>
> numbers의 모든 수들이 음수가 되는 경우를 어떻게 구현할 수 있을까? 처음에는 dfs를 처음 배울 때 사용한 것처럼 stack을 사용한 풀이를 생각했다.
>
> 하지만 stack을 사용하면 numbers배열의 몇번을 Stack에 집어넣었는지 알려줄 수 있게 pair를 사용해야 했고 numbers의 각 요소에 -1을 곱하는 것도 어디부터 시작해야하는지 기준이 애매했다.
>
> 그래서 재귀함수를 사용한 dfs풀이를 사용하게 되었다. 이때 백트래킹과 dfs의 개념을 혼동했다. 때문에 백 트래킹 형식으로 만들어진 코드(틀)안에서 dfs를 구현하려고 했더니 문제가 점점 어렵게 보이기 시작헀고 결국 다른 사람의 풀이를 확인해 해결했다.
>
> 이 풀이의 핵심은 -1을 곱하는 것이 아니라 numbers의 총합, sum에 numbers의 요소들을 뺀다는 것이다. -1을 곱할 필요가 없을 때는 반대로 numbers의 요소를 더한다.
> 이진 트리를 생각하면 더 쉽게 이해할 수 있다. 요소를 뺀다. 요소를 더한다. 이렇게 두가지 분기가 일어나는 것이다.
>
> 분기를 이렇게 잡는 것을 이해하고나서 코드를 완성할 수 있었다.

---

### 네트워크

> 분명 쉽게 해결할 수 있는 문제였는데 stack을 활용한 dfs 방식대로 탐색판을 만들어야 한다는 생각에 갇혀서 문제를 제대로 시작하지 못했다.
>
> 평소 dfs를 짤때는 연결된 경로가 담긴 2차원 배열을 만들고 stack에 시작점을 담으면서 시작했다.
>
> 하지만 이번 문제는 그럴 필요가 없었다. 그냥 연결이 되었다는 지점을 발견하면 그 시점에서 네트워크가 하나 형성 된 것이고, 그 지점과 연결된 모든 컴퓨터를 순회하면서 방문 여부를 확인하면 되는 간단한 문제였다.

---

### 게임 맵 최단거리

> 최단 거리를 BFS, DFS를 사용해서 구할 때는 DP처럼 각 지점이 출발점으로 부터 얼마만큼 떨어져 있는 지 저장하는 배열이 필요함을 잊고 있었다.
>
> 해당 배열을 사용하면 특정 지점의 방문 여부 또한 알 수 있기 때문에 위의 것만 캐치한다면 쉽게 해결할 수 있었다.
