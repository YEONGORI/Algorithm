### 구명보트

> 처음 접근할 때는 완전탐색을 사용했다. 모든 경우의 수를 전부 구한 뒤 최솟 값을 찾는 것을 목표로 했는데 이 방법은 시간 초과가 발생했다.
> 그래서 그리디 알고리즘을 사용해 문제를 다시 풀었다. 모든 선택의 순간에 그 순간 최선의 선택을 한다는 그리디 알고리즘을 왜 사용할 수 있었을까?
>
> 우선 people을 몸무게로 정렬하는 순간 (최소 몸무게 + 최대 몸무게)의 값이 limit를 넘었을 때는 최대 몸무게를 갖는 사람은 보트에 혼자 탈 수 밖에 없다. 즉 반드시 그 사람을 위한 보트가 필요하다.
>
> 만약 limit를 넘지 않는다면 최대 2명이 탈 수 있는 보트에 최소 몸무게와 최대 몸무게의 조합 최적의 조합이다. 이 때문에 이 순간 최적의 선택이 전체 문제에서의 최적의 선택이 된다.
>
> 이미 배를 타고 떠난 사람을 제외한 사람 중 최소 몸무게 최대 몸무게를 더해가며 위의 과정을 반복하면 답을 구할 수 있다.

### 택배 배달과 수거

> 문제를 다 읽고 처음 든 생각은 "가장 멀리 있는 집부터 배달/회수를 하면 되겠구나"였다. 그래서 매 순간 최선의 선택을 하는 그리디 알고리즘을 떠올렸다.
>
> 구현할 때 디테일이 조금 필요하다. 가장 멀리있는 집을 방문해야 하기 때문에 가장 멀리 있는 집이 가장 위로 오는 스택 자료구조를 사용했다.
> 그리고 스택을 자료구조의 배달집(D), 픽업집(P) 중 size가 더 큰 것을 왕복하는 길이를 이동 거리에 더해주었다.
>
> 내가 가려고한 집에 택배가 너무 많다면 계속 방문을 해야하므로 해당 집의 배송/회수 횟수(top)을 계속해서 줄여나간다.
>
> 반대로 가려고 한 집에 배송/회수할 택배가 없다면 pop을 하는 것으로 대체하고 방문은 하지 않는다. 여기서 대부분의 시간을 사용했다. 테스트 케이스 2번이 계속 통과되지 않았던 것이다.
> 배송/회수할 택배가 없는 집이 중간 혹은 가장 마지막에 위치할 수 있다. 나는 앞서서 size가 더 큰 것을 왕복하는 길이를 이동거리에 더했기 때문에 해당 집에 볼일이 없다면 미리 pop해주어야 한다.
> 이 부분이 19-22 line에 있는 두개의 반복문이다.
>
> 이 점을 유의하고 메모장에 배송/회수할 택배가 어떻게 변하는지 직접 입력해본다면 금방 답을 찾을 수 있다.
