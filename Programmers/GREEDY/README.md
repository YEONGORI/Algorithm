### 구명보트

> 처음 접근할 때는 완전탐색을 사용했다. 모든 경우의 수를 전부 구한 뒤 최솟 값을 찾는 것을 목표로 했는데 이 방법은 시간 초과가 발생했다.
> 그래서 그리디 알고리즘을 사용해 문제를 다시 풀었다. 모든 선택의 순간에 그 순간 최선의 선택을 한다는 그리디 알고리즘을 왜 사용할 수 있었을까?
>
> 우선 people을 몸무게로 정렬하는 순간 (최소 몸무게 + 최대 몸무게)의 값이 limit를 넘었을 때는 최대 몸무게를 갖는 사람은 보트에 혼자 탈 수 밖에 없다. 즉 반드시 그 사람을 위한 보트가 필요하다.
>
> 만약 limit를 넘지 않는다면 최대 2명이 탈 수 있는 보트에 최소 몸무게와 최대 몸무게의 조합 최적의 조합이다. 이 때문에 이 순간 최적의 선택이 전체 문제에서의 최적의 선택이 된다.
>
> 이미 배를 타고 떠난 사람을 제외한 사람 중 최소 몸무게 최대 몸무게를 더해가며 위의 과정을 반복하면 답을 구할 수 있다.

---

### 택배 배달과 수거

> 문제를 다 읽고 처음 든 생각은 "가장 멀리 있는 집부터 배달/회수를 하면 되겠구나"였다. 그래서 매 순간 최선의 선택을 하는 그리디 알고리즘을 떠올렸다.
>
> 구현할 때 디테일이 조금 필요하다. 가장 멀리있는 집을 방문해야 하기 때문에 가장 멀리 있는 집이 가장 위로 오는 스택 자료구조를 사용했다.
> 그리고 스택을 자료구조의 배달집(D), 픽업집(P) 중 size가 더 큰 것을 왕복하는 길이를 이동 거리에 더해주었다.
>
> 내가 가려고한 집에 택배가 너무 많다면 계속 방문을 해야하므로 해당 집의 배송/회수 횟수(top)을 계속해서 줄여나간다.
>
> 반대로 가려고 한 집에 배송/회수할 택배가 없다면 pop을 하는 것으로 대체하고 방문은 하지 않는다. 여기서 대부분의 시간을 사용했다. 테스트 케이스 2번이 계속 통과되지 않았던 것이다.
> 배송/회수할 택배가 없는 집이 중간 혹은 가장 마지막에 위치할 수 있다. 나는 앞서서 size가 더 큰 것을 왕복하는 길이를 이동거리에 더했기 때문에 해당 집에 볼일이 없다면 미리 pop해주어야 한다.
> 이 부분이 19-22 line에 있는 두개의 반복문이다.
>
> 이 점을 유의하고 메모장에 배송/회수할 택배가 어떻게 변하는지 직접 입력해본다면 금방 답을 찾을 수 있다.

---

### 섬 연결하기

> 최단 거리로 모든 섬들을 연결하는 전형적인 그리디 문제이다. 처음에 2차원 배열을 사용해서 그래프를 우선적으로 만들어주었다. 그 이후로는 MST(최소 신장 트리)를 만들어야 했는데 여기서 사용하는 알고리즘을 까먹어서 검색을 활용했다. 크루스컬 또는 프림 알고리즘을 사용해 문제를 해결할 수 있는데 이번에 사용된 알고리즘은 프림 알고리즘이다.
>
> 간단히 알고리즘을 설명하면 우선 시작 섬 하나를 MST에 넣는다. 그리고 연결된 섬들 중 가장 cost가 적은 섬을 MST에 추가 시킨다. 지금부터는 MST에 있는 섬들과 연결된 섬들 중 가장 cost가 적은 섬을 계속해서 MST에 추가해나가면 된다.
>
> 매 순간순간 최선의 선택(MST와 연결된 섬중 가장 cost가 작은 섬 연결)이 전체 문제에서도 최선의 선택이 되었기 때문에 그리디 알고리즘이라 할 수 있다.

---

### 광물 캐기

> 문제를 읽고 생각한 풀이는 완전 탐색이었다. permutation을 사용해 완전 탐색 풀이를 완성하기까지 걸린 시간은 얼마 되지 않았지만, 테스트 케이스에서 시간 초과가 발생했다.
>
> 사실 문제를 읽자마자 떠오른 풀이는 그리디였다. 그때그때 최고 효율의 곡괭이를 사용한다면 전체적으로도 최고 효율을 뽑아낼 수 있을 것이라 생각했다.
>
> 가치가 높은 곡괭이로 가치가 높은 광물 영역을 순서대로 캐는 것이 그리디 풀이의 핵심 이지만 광물 영역을 가치 순으로 정렬한다는 생각을 하지 못해 그리디 풀이를 포기했었다.
>
> 그리디 풀이를 완성하기 위해서는
```
works = list(
    reversed(sorted(list(works), key=lambda x: (x[0], x[1], x[2]))))
```
> 광물 영역을 가치순으로 정렬하는 위의 코드가 반드시 필요하다.